each 以外のメソッドにも [[c:Enumerable]] の機能を提供するためのラッパークラスです。
#@since 1.8.7
また、外部イテレータとしても使えます。
#@end
#@until 1.8.8
Ruby 1.8.8 以降では Enumerable::Enumerator は Enumerator になっています。
#@end

[[c:Enumerable]] モジュールは、 [[m:Module#include]] 先のクラスが持つ
each メソッドを元に様々なメソッドを提供します。
例えば Array#map は [[m:Array#each]] の繰り返しを元にして定義されます。
Enumerator を介することにより [[m:String#each_byte]] のような
異なる名前のイテレータについても each と同様に Enumerable の機能を利用できます。

Enumerator を生成するには
#@since 1.8.8
[[m:Enumerator.new]]
#@else
[[m:Enumerable::Enumerator.new]]
#@end
あるいは [[m:Object#to_enum]], [[m:Object#enum_for]] を利用します。
#@since 1.9.1
また、一部のイテレータはブロックを渡さずに呼び出すと繰り返しを実行する代わりに
enumerator を生成して返します。
#@end

#@since 1.9.1
=== 注意
外部イテレータとしての機能は [[c:Fiber]] を用いて実装されているため Fiber と同じ制限があります。
例えば以下のようなスレッドをまたいだ呼び出しはエラーになります。

 a = nil
 Thread.new do
   a = [1, 2, 3].each
   a.next
 end.join
 
 p a.next
 #=> t.rb:7:in `next': fiber called across threads (FiberError)
         from t.rb:7:in `<main>'
#@end

== Class Methods

#@since 1.8.8
--- new(obj, method = :each, *args) -> Enumerator
#@else
--- new(obj, method = :each, *args) -> Enumerable::Enumerator
#@end

オブジェクト obj について、 each の代わりに method という
名前のメソッドを使って繰り返すオブジェクトを生成して返します。
args を指定すると、 method の呼び出し時に渡されます。

@param obj イテレータメソッドのレシーバとなるオブジェクト
@param method イテレータメソッドの名前を表すシンボルまたは文字列
@param args イテレータメソッドの呼び出しに渡す任意個の引数

例:

  str = "xyz"
  
#@since 1.8.8
  enum = Enumerator.new(str, :each_byte)
#@else
  enum = Enumerable::Enumerator.new(str, :each_byte)
#@end
  p enum.map {|b| '%02x' % b }   # => ["78", "79", "7a"]


#@since 1.8.8
--- new{|y| ... }                   -> Enumerator

Enumerator オブジェクトを生成して返します。与えられたブロックは Enumerator::Yielder オブジェクトを
引数として実行されます。

生成された Enumerator オブジェクトに対して each を呼ぶと、この生成時に指定されたブロックを
実行し、Yielder オブジェクトに対して << メソッドが呼ばれるたびに、
each に渡されたブロックが繰り返されます。

new に渡されたブロックが終了した時点で each の繰り返しが終わります。
このときのブロックの返り値が each の返り値となります。

例:

  enum = Enumerator.new{|y|
    (1..10).each{|i|   
      y << i if i % 5 == 0
    }
  }
  enum.each{|i| p i }  

  #=>  5 
      10


  fib = Enumerator.new { |y|
    a = b = 1
    loop {
      y << a
      a, b = b, a + b
    }
  }

  p fib.take(10) #=> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


#@end

== Methods

--- each {...} -> object

生成時のパラメータに従ってブロックを繰り返します。
生成時に指定したイテレータの戻り値をそのまま返します。

例:
  str = "Yet Another Ruby Hacker"
  
#@since 1.8.8
  enum = Enumerator.new(str, :scan, /\w+/)
#@else
  enum = Enumerable::Enumerator.new(str, :scan, /\w+/)
#@end
  enum.each {|word| p word }              # => "Yet"
                                          #    "Another"
                                          #    "Ruby"
                                          #    "Hacker"

  str.scan(/\w+/) {|word| p word }        # => "Yet"
                                          #    "Another"
                                          #    "Ruby"
                                          #    "Hacker"

#@since 1.8.7
--- next -> object
「次」のオブジェクトを返します。

現在までの列挙状態に応じて「次」のオブジェクトを返し、列挙状態を1つ分進めます。
#@until 1.9.1
列挙が既に最後へ到達している場合は、
列挙状態を最初まで巻き戻すとともに
[[c:StopIteration]] 例外を発生します。
#@else
列挙が既に最後へ到達している場合は、
[[c:StopIteration]] 例外を発生します。このとき列挙状態は変化しません。
つまりもう一度 next を呼ぶと再び例外が発生します。
#@end

next メソッドによる外部列挙の状態は他のイテレータメソッドによる
内部列挙には影響を与えません。
ただし、 [[m:IO#each_line]] のようにおおもとの列挙メカニズムが副作用を
伴っている場合には影響があり得ます。

@raise StopIteration 列挙状態が既に最後へ到達しているとき
#@since 1.8.8
@see [[m:Enumerator#rewind]]
#@else
@see [[m:Enumerable::Enumerator#rewind]]
#@end

例1:
    str = "xyz"
    enum = str.each_byte
    
    str.bytesize.times do
      puts enum.next
    end
        # => 120
        #    121
        #    122

例2:
    str = "xyz"
    enum = str.each_byte
    
    begin
      puts enum.next while true
    rescue StopIteration
      puts "iteration reached at end"
      puts enum.next
    end
        # => 120
        #    121
        #    122
        #    iteration reached at end
        #    120

例3: [[m:Kernel.#loop]] は StopIteration を捕捉します。
    str = "xyz"
    enum = str.each_byte
    loop do
      puts enum.next
    end
        # => 120
        #    121
        #    122

#@since 1.9.2
--- feed(obj) -> nil

Enumerator 内部の yield が返す値を設定します。

これで値を設定しなかった場合は yield は nil を返します。

この値は内部で yield された時点でクリアされます。

  # 例
  # (1), (2), ... (10) の順に実行される
  o = Object.new
  def o.each
    x = yield         # (2) blocks
    p x               # (5) => "foo"
    x = yield         # (6) blocks
    p x               # (8) => nil
    x = yield         # (9) blocks
    p x               # not reached w/o another e.next
  end
  
  e = o.to_enum
  e.next              # (1)
  e.feed "foo"        # (3)
  e.next              # (4)
  e.next              # (7)
                      # (10)
@param obj Enumerator 内部の yield が返す値
@raise TypeError すでに値をこのメソッドでセットしている場合に発生します


--- next_values -> Array

「次」のオブジェクトを配列で返します。

[[m:Enumerator#next]] とほぼ同様の挙動をします。終端まで到達した場合は
[[c:StopIteration]] 例外を発生させます。

このメソッドは、
  yield
と
  yield nil
を区別するために使えます。

next メソッドによる外部列挙の状態は他のイテレータメソッドによる
内部列挙には影響を与えません。
ただし、 [[m:IO#each_line]] のようにおおもとの列挙メカニズムが副作用を
伴っている場合には影響があり得ます。

  # 例、 next と next_values の違いを
  o = Object.new
  def o.each
    yield
    yield 1
    yield 1, 2
    yield nil
    yield [1, 2]
  end
  e = o.to_enum
  p e.next_values
  p e.next_values
  p e.next_values
  p e.next_values
  p e.next_values
  e = o.to_enum
  p e.next
  p e.next
  p e.next
  p e.next
  p e.next
  
  ## yield args       next_values      next
  #  yield            []               nil
  #  yield 1          [1]              1
  #  yield 1, 2       [1, 2]           [1, 2]
  #  yield nil        [nil]            nil
  #  yield [1, 2]     [[1, 2]]         [1, 2]

@raise StopIteration 列挙状態が既に最後へ到達しているとき
@see [[m:Enumerator#next]], [[m:Enumerator#peek]], [[m:Enumerator#peek_values]]

--- peek -> object
「次」のオブジェクトを返しますが、列挙状態を変化させません。

[[m:Enumerator#next]] のように
現在までの列挙状態に応じて「次」のオブジェクトを返しますが、
next と異なり列挙状態を変更しません。

列挙が既に最後へ到達している場合は、[[c:StopIteration]] 例外を発生します。

  # 例
  a = [1,2,3]
  e = a.to_enum
  p e.next   #=> 1
  p e.peek   #=> 2
  p e.peek   #=> 2
  p e.peek   #=> 2
  p e.next   #=> 2
  p e.next   #=> 3
  p e.next   #raises StopIteration

@raise StopIteration 列挙状態が既に最後へ到達しているとき
@see [[m:Enumerator#next]], [[m:Enumerator#next_values]], [[m:Enumerator#peek_values]]
--- peek_values -> Array

[[m:Enumerator#next_values]] のように「次」のオブジェクトを
配列で返しますが、列挙状態を変化させません。

[[m:Enumerator#next]], [[m:Enumerator#next_values]] のように
現在までの列挙状態に応じて「次」のオブジェクトを返しますが、
next と異なり列挙状態を変更しません。

列挙が既に最後へ到達している場合は、[[c:StopIteration]] 例外を発生します。

このメソッドは [[m:Enumerator#next_values]] と同様
  yield
と
  yield nil
を区別するために使えます。
  
  # 例
  o = Object.new
  def o.each
    yield
    yield 1
    yield 1, 2
  end
  e = o.to_enum
  p e.peek_values    #=> []
  e.next
  p e.peek_values    #=> [1]
  p e.peek_values    #=> [1]
  e.next
  p e.peek_values    #=> [1, 2]
  e.next
  p e.peek_values    # raises StopIteration

@raise StopIteration 列挙状態が既に最後へ到達しているとき
@see [[m:Enumerator#next]], [[m:Enumerator#next_values]], [[m:Enumerator#peek_values]]


#@end
--- rewind -> self
列挙状態を巻き戻します。

next メソッドによる外部列挙の状態を最初まで巻き戻します。 self を返します。

#@since 1.9.2
内包するオブジェクトが rewind メソッドを持つとき(respond_to?(:rewind) に
真を返すとき) は、その rewind メソッドを呼び出します。
#@end

#@since 1.8.8
@see [[m:Enumerator#next]]
#@else
@see [[m:Enumerable::Enumerator#next]]
#@end

例:
    str = "xyz"
    enum = str.each_byte
    
    p enum.next # => 120
    p enum.next # => 121
    enum.rewind
    p enum.next # => 120

#@since 1.9.2
--- with_index(offset = 0) {|(*args), idx| ... } -> object
--- with_index(offset = 0) -> Enumerator
#@else
--- with_index {|(*args), idx| ... } -> object
--- with_index -> Enumerator
#@end

生成時のパラメータに従って、要素にインデックスを添えて繰り返します。
#@since 1.9.2
インデックスは offset から始まります。
#@else
インデックスは 0 から始まります。
#@end

ブロックを指定した場合の戻り値は生成時に指定したレシーバ自身です。

例:
    str = "xyz"
    
#@since 1.8.8
    enum = Enumerator.new(str, :each_byte)
#@else
    enum = Enumerable::Enumerator.new(str, :each_byte)
#@end
    enum.with_index {|byte, idx| p [byte, idx] }
        # => [120, 0]
        #    [121, 1]
        #    [122, 2]
#@since 1.9.2
    
    require "stringio"
    StringIO.new("foo|bar|baz").each("|").with_index(1) {|s, i| p [s, i] }
        # => ["foo|", 1]
        #    ["bar|", 2]
        #    ["baz", 3]
#@end


生成時のパラメータに従って、要素にインデックスを添えてブロックを繰り返します。
インデックスは 0 から始まります。
#@since 1.9.2
[[m:Enumerator#with_index]] は offset 引数を受け取りますが、
each_with_index は受け取りません (引数はイテレータメソッドにそのまま渡されます)。
#@end

#@since 1.8.8
--- with_object(obj) -> Enumerator
--- with_object(obj) {|(*args), memo_obj| ... } -> object

繰り返しの各要素に obj を添えてブロックを繰り返し、obj を返り値として返します。

obj には任意のオブジェクトを渡すことができます。

ブロックが渡されなかった場合は、上で説明した繰り返しを実行し、
最後に obj を返す [[c:Enumerator]] を返します。

==== 例
  # 0,1,2 と呼びだす enumeratorを作る
  to_three = Enumerator.new do |y|
    3.times do |x|
      y << x
    end
  end
  
  to_three_with_string = to_three.with_object("foo")
  to_three_with_string.each do |x,string|
    puts "#{string}: #{x}"
  end
  # => foo:0
  # => foo:1
  # => foo:2

@param obj 繰り返しの各要素に添えて渡されるオブジェクト
@see [[m:Enumerable#each_with_object]]

#@end
#@end

#@# 以下のクラスはユーザが直接触れるべきではないのでドキュメントは
#@# 書かない
#@# = class Enumerator::Generator
#@# = class Enumerator::Yielder
