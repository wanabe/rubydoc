= class Thread < Object

スレッドを表すクラスです。スレッドとはメモリ空間を共有して同時に実行される制御の流れです。
Thread を使うことで並行プログラミングが可能になります。

#@include(thread.inc)

== Class Methods
--- abort_on_exception             -> bool
--- abort_on_exception=(newstate)

真の時は、いずれかのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。false の場合、あるスレッドで起こった例外は、[[m:Thread#join]]
などで検出されない限りそのスレッドだけをなにも警告を出さずに終了させます。

デフォルトは false です。

[[ref:c:Thread#exception]]を参照してください。

@param newstate スレッド実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。

#@since 1.9.1
--- critical             -> nil
#@else
--- critical             -> bool
#@end
--- critical=(newstate)

#@since 1.9.1
サポートされていません。警告を出力し、何もせずに nil を返します。
#@else
真である間、スレッドの切替えを行いません。

カレントスレッドが停止状態になった場合や、シグナルに割り込まれた場合には、
自動的に false になります。
ただし、[[m:Thread.new]] によりスレッドを生成した場合には、critical 
の値に関わらず そのスレッドは実行されます。
また、[[m:Thread.pass]] により明示的に切替えることもできます。

デフォルトは false です。

注意: I/O や GC、拡張ライブラリがからむとこのフラグは無視さ
れることもあります。排他制御を行うにはこのメソッドに頼らず
[[c:Mutex]] や [[c:Monitor]] を使うべきです。

@param newstate スレッドの切替えを許すかどうかを、true か false で指定します。
#@end

--- current    -> Thread

現在実行中のスレッド(カレントスレッド)を返します。

  p Thread.current #=> #<Thread:0x4022e6fc run>

--- exit    -> ()

カレントスレッドに対して [[m:Thread#exit]] を呼びます。

--- kill(thread)    -> Thread

指定したスレッド thread に対して [[m:Thread#exit]] を呼びます。終了したスレッドを返します。

@param thread 終了したい Thread オブジェクトを指定します。

  th = Thread.new do
  end
    
  p Thread.kill(th)     #=> #<Thread:0x40221bc8 dead>

--- list    -> [Thread]

#@since 1.8.0
全ての生きているスレッドを含む配列を生成して返します。aborting 状態であるスレッド
も要素に含まれます。
#@else
生きているスレッドのうち、実行中(run)または停止中(stop)のスレッド
の配列を返します。
#@end

  Thread.new do
    sleep 
  end
  sleep 0.1
  
  p Thread.list   #=> [#<Thread:0x40377a54 sleep>, #<Thread:0x4022e6fc run>]

--- main    -> Thread

メインスレッドを返します。

  p Thread.main #=> #<Thread:0x4022e6fc run>

--- start(*arg) {|*arg| ... }       -> Thread
--- fork(*arg) {|*arg| ... }        -> Thread

スレッドを生成して、ブロックの評価を開始します。
生成したスレッドを返します。

基本的に [[m:Thread.new]] と同じですが、
new メソッドと違い initialize メソッドを呼びません。

@param arg 引数 arg はそのままブロックに渡されます。スレッドの開始と同時にその
           スレッド固有のローカル変数に値を渡すために使用します。

@raise ThreadError 現在のスレッドが属する [[c:ThreadGroup]] が freeze されている場合に発生します。またブロックを与えられずに呼ばれた場合にも発生します。


注意:

例えば、以下のコードは間違いです。スレッドの実行が開始される前に
変数 i が書き変わる可能性があるからです。

  for i in 1..5
     Thread.start { p i }
  end

上の例は以下のように書き直すべきです。

  for i in 1..5
     Thread.start(i) {|t| p t }
  end

--- new(*arg) {|*arg| ... }         -> Thread

スレッドを生成して、ブロックの評価を開始します。
生成したスレッドを返します。

@param arg 引数 arg はそのままブロックに渡されます。スレッドの開始と同時にその
           スレッド固有のローカル変数に値を渡すために使用します。

@raise ThreadError 現在のスレッドが属する [[c:ThreadGroup]] が freeze されている場合に発生します。またブロックを与えられずに呼ばれた場合にも発生します。

注意:

例えば、以下のコードは間違いです。スレッドの実行が開始される前に
変数 i が書き変わる可能性があるからです。

  for i in 1..5
     Thread.new { p i }
  end

上の例は以下のように書き直すべきです。

  for i in 1..5
     Thread.new(i) {|t| p t }
  end

--- pass    -> nil

他のスレッドに実行権を譲ります。実行中のスレッドの状態を変えずに、
他の実行可能状態のスレッドに制御を移します。

 Thread.new do
   (1..3).each{|i|
     p i
     Thread.pass
   }
   exit
 end
 
 loop do
   Thread.pass
   p :main
 end

 #=>
 1
 :main
 2
 :main
 3
 :main

--- stop     -> nil

他のスレッドから [[m:Thread#run]] メソッドで再起動されるまで、カレ
ントスレッドの実行を停止します。

#@since 1.9.1
--- exclusive { ... }  -> object
#@# 1.8 以前は ../thread.rb にあります。
VM グローバルの Mutex をロックし、ブロックを実行します。

このクラスメソッドの挙動は 1.8 以前とは違います。
Thread.exclusive は VM グローバルの [[m:Thread::MUTEX_FOR_THREAD_EXCLUSIVE]] の
synchronize を呼び出しているだけで、Thread.exclusive していないスレッドは動きます。
[[c:Mutex]] や [[c:Monitor]] などの他の排他制御の方法を検討してください。

#@end

== Instance Methods

--- [](name)    -> object | nil

name に対応したスレッドに固有のデータを取り出します。
name に対応するスレッド固有データがなければ nil を返し
ます。

@param name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。

--- []=(name,val)

val を name に対応するスレッド固有のデータとして格納します。

@param name スレッド固有データのキーを文字列か [[c:Symbol]] で指定します。文字列を指定した場合は [[m:String#to_sym]] によりシンボルに変換されます。

@param val スレッド固有データを指定します。nil を指定するとそのスレッド固有データは削除されます。

--- abort_on_exception               -> bool
--- abort_on_exception=(newstate)

真の場合、そのスレッドが例外によって終了した時に、インタプリタ
全体を中断させます。false の場合、あるスレッドで起こった例
外は、[[m:Thread#join]] などで検出されない限りそのスレッ
ドだけをなにも警告を出さずに終了させます。

デフォルトは偽です。[[ref:c:Thread#exception]]を参照してください。

@param newstate 自身を実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。

--- alive?     -> bool

スレッドが「生きている」時、true を返します。

[[m:Thread#status]] が真を返すなら、このメソッドも真です。

--- exit         -> self
--- kill         -> self
--- terminate    -> self

スレッドの実行を終了させます。終了時に ensure 節が実行されます。

ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより
終了したスレッドの [[m:Thread#value]] の返り値は不定です。
自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。

[[m:Kernel.#exit]] と違い例外  [[c:SystemExit]] を発生しません。

  th1 = Thread.new do
    begin
      sleep 10
    ensure
      p "this will be displayed"
    end
  end

  sleep 0.1
  th1.kill

  #=> "this will be displayed"

#@since 1.9.1
@see [[m:Kernel.#exit]], [[m:Kernel.#exit!]]
#@else
@see [[m:Thread#exit!]], [[m:Kernel.#exit]], [[m:Kernel.#exit!]]
#@end

#@if("1.8.6" <= version and version < "1.9.1")
--- exit!         -> self
--- kill!         -> self
--- terminate!    -> self

ensure 節を実行せずにスレッドの実行を終了させます。

ただし、スレッドは終了処理中(aborting)にはなりますが、
直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより
終了したスレッドの [[m:Thread#value]] の返り値は不定です。
自身がメインスレッドであるか最後のスレッドである場合は、プロセスを [[m:Kernel.#exit]](0) 
により終了します。

  th1 = Thread.new do
    begin
      sleep 10
    ensure
      p "th1: this will be displayed"
    end
  end
  th2 = Thread.new do
    begin
      sleep 10
    ensure
      p "th2: this will NOT be displayed"
    end
  end
  
  th1.kill
  th2.kill!

  #=> "th1: this will be displayed"

@see [[m:Thread#exit]], [[m:Kernel.#exit]], [[m:Kernel.#exit!]]
#@end

--- group    -> ThreadGroup | nil

スレッドが属している [[c:ThreadGroup]] オブジェクトを返します。
死んでいるスレッドは nil を返します。

    p Thread.current.group == ThreadGroup::Default
    # => true

--- join           -> self
#@since 1.8.0
--- join(limit)    -> self | nil
#@end

スレッド self の実行が終了するまで、カレントスレッドを停止し
ます。self が例外により終了していれば、その例外がカレントス
レッドに対して発生します。

#@since 1.8.0
limit を指定して、limit 秒過ぎても自身が終了しない場合、nil を返します。

@param limit タイムアウトする時間を整数か小数で指定します。単位は秒です。
#@end

@raise ThreadError join を実行することによってデッドロックが起きる場合に発生します。またカレントスレッドを join したときにも発生します。

以下は、生成したすべてのスレッドの終了を待つ例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| t.join}

--- key?(name)     -> bool

name に対応したスレッドに固有のデータが定義されていれば
true を返します。

@param name 文字列か [[c:Symbol]] で指定します。

--- keys    -> [Symbol]

スレッド固有データに関連づけられたキーの配列を返します。キーは
[[c:Symbol]] で返されます。

    th = Thread.current
    th[:foo] = 'FOO'
    th['bar'] = 'BAR'
    p th.keys

    #=> [:bar, :foo]

--- priority    -> Integer
--- priority=(val)

スレッドの優先度を返します。この値の大きいほど優先度が高くなります。
メインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの
priority を引き継ぎます。

#@since 1.9.1
@param val スレッドの優先度を指定します。プラットフォームに依存します。
#@else
@param val スレッドの優先度を指定します。負の値も指定できます。
#@end

--- raise(error_type, message, traceback)     -> ()

自身が表すスレッドで強制的に例外を発生させます。

@param error_type [[m:Kernel.#raise]] を参照してください。

@param message [[m:Kernel.#raise]] を参照してください。

@param traceback [[m:Kernel.#raise]] を参照してください。

  Thread.new {
    sleep 1
    Thread.main.raise "foobar"
  }

  begin
    sleep
  rescue
    p $!, $@
  end

  => #<RuntimeError: foobar>
     ["-:3"]

--- run    -> self

停止状態(stop)のスレッドを再開させます。
[[m:Thread#wakeup]] と異なりすぐにスレッドの切り替え
を行います。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。

--- safe_level    -> Integer

self のセーフレベルを返します。カレントスレッドの
safe_level は、[[m:$SAFE]] と同じです。

セーフレベルについては[[d:spec/safelevel]]を参照してください。

--- status    -> String | false | nil

生きているスレッドの状態を文字列 "run"、"sleep", "aborting" のいず
れかで返します。正常終了したスレッドに対して false、例外によ
り終了したスレッドに対して nil を返します。
#@#((-((<ruby 1.6 feature>)): version 1.6.5 までは、終了処理中
#@#(aborting)のスレッドに対しては "run" を返していました-))

[[m:Thread#alive?]] が真を返すなら、このメソッドも真です。

--- stop?    -> bool

スレッドが終了(dead)あるいは停止(stop)している時、true を返します。

--- value    -> object 

スレッド self が終了するまで待ち([[m:Thread#join]] と同じ)、
そのスレッドのブロックが返した値を返します。スレッド実行中に例外が
発生した場合には、その例外を再発生させます。

スレッドが [[m:Thread#kill]] によって終了した場合は、返り値は不定です。

以下は、生成したすべてのスレッドの終了を待ち結果を出力する例です。

   threads = []
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })
   threads.push(Thread.new { n = rand(5); sleep n; n })

   threads.each {|t| p t.value}

最後の行で、待ち合わせを行っていることがわかりにくいと思うなら以下
のように書くこともできます。

   threads.each {|t| p t.join.value}

--- wakeup    -> self

停止状態(stop)のスレッドを実行可能状態(run)にします。

@raise ThreadError 死んでいるスレッドに対して実行すると発生します。


#@since 1.9.2
--- add_trace_func(pr) -> Proc

スレッドにトレース用ハンドラを追加します。

追加したハンドラを返します。

@param pr トレースハンドラ([[c:Proc]] オブジェクト)
@see [[m:Thread#set_trace_func]] [[m:Kernel.#set_trace_func]]

--- set_trace_func(pr) -> Proc | nil

スレッドにトレース用ハンドラを設定します。

nil を渡すとトレースを解除します。

設定したハンドラを返します。

@param pr トレースハンドラ([[c:Proc]] オブジェクト) もしくは nil
@see [[m:Thread#add_trace_func]] [[m:Kernel.#set_trace_func]]

--- backtrace    -> [String] | nil
スレッドの現在のバックトレースを返します。

スレッドがすでに終了している場合は nil を返します。

#@end
== Constants

#@since 1.9.1
--- MUTEX_FOR_THREAD_EXCLUSIVE

[[m:Thread.exclusive]]用の[[c:Mutex]]オブジェクトです。
#@end
