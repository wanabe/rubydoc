= class WIN32OLE < Object

OLEオートメーションオブジェクトをRubyで操作するためのクラスです。

Windowsの多くのアプリケーションやライブラリは、COMと呼ばれるAPI群を利用して他のプログラムから操作できます。WIN32OLEがサポートしているのは、COMのAPIのうち、特にインタープリタ用のインターフェイスであるOLEオートメーション（IDispatchインターフェイス）とそれに付随するリフレクション用のインターフェイスです。

これらのインターフェイスをサポートしている代表的なWindowsアプリケーションに、Office、IE、iTunes、Illustratorがあります。また、WMI、WshShellなどのライブラリを利用してWindowsの情報を操作することも可能です。

=== サンプルコード

  require 'win32ole'

  excel = WIN32OLE.new('Excel.Application')
  workbook = excel.Workbooks.Open('workbook.xls')
  workbook.PrintOut
  workbook.Close(:SaveChanges => false)
  excel.Quit

#@since 1.9.1

=== マルチスレッドでの利用制限

注）以下の記述はWIN32OLEの将来のバージョンの仕様を規定するものではありません。

WIN32OLEはシングルスレッドモードでCOMとインターフェイスします。このため、ruby 1.9以降のRubyのThreadとネイティブスレッドが1対1で対応する実行環境ではスレッドをまたがる呼び出しはエラーとなります。

  excel = WIN32OLE.new('Excel.Application')
  Thread.start do
    workbook = excel.Workbooks.Open('workbook.xls') #=> HRESULT error code:0x800401f0
    workbook.PrintOut
    workbook.Close(:SaveChanges => false)
  end.join
  excel.Quit

発生するエラーはThreadの実行方法によって0x800401f0（CO_E_NOTINITIALIZED）または0x8001010e（RPC_E_WRONG_THREAD）です。

#@end

== Class Methods

#@since 1.9.1

--- create_guid -> String

GUID(グローバル一意識別子：Global Unique Identifier)を生成します。

GUIDは、COMのクラス識別子(CLSID)、インターフェイス識別子(IID)など多数の領域でWindows上のオブジェクトの識別に利用される128ビットの値です。

WIN32OLEが生成するGUIDは以下の形式によるGUIDの文字列表現です。なお00〜FFはGUIDの先頭からのバイト位置を示します。これはレジストリのキーとして利用される形式です。

  {33221100-5544-7766-8899-AABBCCDDEEFF}

@return GUIDの文字列表現を返します。

   WIN32OLE.create_guid   # => "{????????-????-????-????-????????????}"

--- locale -> Fixnum

WIN32OLEがオートメーション呼び出し時に設定するロケール識別子(LCID)を取得します。

OLEオートメーションでは、UNIXで利用される"ja_JP"などの国名と言語名を「_」で接続した文字列ではなく、32ビット整数で示します。32ビットの内訳は上位16ビットが予約領域で0、下位16ビットが言語ID(LANGID）です。LANGIDは、0〜9ビットでプライマリ言語ID、10〜15ビットでサブ言語IDを示します。

ロード時の既定値は[[m:WIN32OLE::LOCALE_SYSTEM_DEFAULT]]です。

@return WIN32OLEがオートメーション呼び出し時に設定するロケール識別子(LCID)を返します。

   lcid = WIN32OLE.locale

--- locale=(lcid) -> nil

WIN32OLEがオートメーション呼び出し時に設定するロケール識別子(LCID)を設定します。

OLEオートメーションでは、UNIXで利用される"ja_JP"などの国名と言語名を「_」で接続した文字列ではなく、32ビット整数で示します。32ビットの内訳は上位16ビットが予約領域で0、下位16ビットが言語ID(LANGID）です。LANGIDは、0〜9ビットでプライマリ言語ID、10〜15ビットでサブ言語IDを示します。

@param lcid 新たに設定するロケール識別子を整数で指定します。
@raise WIN32OLERuntimeError システムにインストールされていないロケールを指定すると発生します。

   WIN32OLE.locale = 1033 # set locale English(U.S)
   obj = WIN32OLE_VARIANT.new("$100,000", WIN32OLE::VARIANT::VT_CY)

オブジェクトがサポートしていないロケールを設定した場合、オブジェクトのメソッド呼び出し時にDISP_E_UNKNOWNLCID(HRESULT error code:0x8002000C)や、TYPE_E_INVDATAREAD(HRESULT error code:0x80028018)などを理由としたWIN32OLERuntimeError例外となります。ほとんどすべての場合において、既定値を変更する必要はありません。

#@end

--- codepage -> Fixnum

WIN32OLEがOLEオートメーションのインターフェイスに利用するコードページを取得します。

OLEオートメーションに利用する文字列はUnicodeでエンコードします。WIN32OLEはここで示されたコードページを利用してRubyのStringとUnicodeの相互変換を行います。

ロード時の既定値はEncoding.default_internal、またはEncoding.default_internalがnilの場合はEncoding.default_externalによって求めたエンコーディングに対応するコードページです。もし、該当するコードページが見つからない場合は、[[m:WIN32OLE::CP_ACP]]を利用します。

@return WIN32OLEがオートメーション呼び出しの文字列変換に利用するコードページを返します。

   WIN32OLE.codepage   # => 932 （日本語Windowsの既定値）

--- codepage=(cp) -> nil

WIN32OLEがOLEオートメーションのインターフェイスに利用するコードページを設定します。

WIN32OLEは、OLEオートメーション呼び出しに利用する文字列のUnicode変換にここで設定したコードページを利用します。
通常、WIN32OLEはロード時のEncoding.default_internalまたはEncoding.default_externalから適切なコードページを判断し、それを利用します。したがって、当メソッドを呼び出す必要があるのは、WIN32OLEをrequireしたスクリプトと異なるエンコーディングを利用しているスクリプトや、異なるエンコーディングを利用しているファイルから読み込んだ文字列を利用してWIN32OLEを呼び出す場合です。

   WIN32OLE.codepage = WIN32OLE::CP_UTF8

--- connect(ole) -> WIN32OLE

現在実行中のOLEオートメーションサーバに接続します。

connectメソッドは、COMのモニカを利用して、現在実行中のOLEオートメーションサーバを検索し、接続します。接続に成功した場合、該当サーバを操作可能なWIN32OLEオブジェクトが返ります。

@param ole 接続対象のサーバを示すPROGID、CLSIDまたはモニカ（別名）を指定します。

@return ole引数で特定されるWIN32OLEオブジェクトを返します。

   WIN32OLE.connect('Excel.Application') # => WIN32OLE object which represents running Excel.

: PROGID
  OLEオートメーションサーバを識別するための文字列。通常「ベンダー名.アプリケーション名.インターフェイス名」の形式を取ります。レジストリのHKEY_CLASSES_ROOTの「.」で始まらないキーとして登録されます。
: CLSID
  OLEオートメーションサーバを含むCOMのクラスを識別するための128ビットGUID。文字列表現は、レジストリのHKEY_CLASSES_ROOT\CLSID下のキーとして登録されます。
: モニカ
  モニカは、URIのようにWindows上のリソースを一意に識別するためのオブジェクトのインターフェイスで、文字表現を持ちます。詳細については[[url:http://msdn.microsoft.com/en-us/library/ms691261(v=VS.85).aspx]]を参照してください。

--- const_load(ole, mod = WIN32OLE) -> ()

OLEオートメーションサーバが保持する定数を読み込み、指定されたモジュールに組み込みます。

OLEオートメーションサーバは、定数をクライアントへ提供できます。

const_loadメソッドはこれらの定数を読み込み、指定したモジュールに組み込むことで参照可能とします。

@param ole 定数を読み込む対象のWIN32OLEオブジェクトまたはタイプライブラリ名（文字列）を指定します。
@param mod 定数を定義する対象のモジュールを指定します。省略時はWIN32OLEに組み込まれます。

OLEオートメーションの定数は通常、VBのコード規約に準じて、vbConstantsのように小文字で始まります。しかし、Rubyの定数は大文字で開始する規則のため、WIN32OLEによってVbConstantsのように自動的に先頭が大文字化されます。

また、先頭が英字で始まらない定数については、CONSTANTSハッシュに登録されます。この場合、元の定数名がキーとなります。

   module EXCEL_CONST
   end
 
   excel = WIN32OLE.new('Excel.Application')
   WIN32OLE.const_load(excel, EXCEL_CONST)
   puts EXCEL_CONST::XlTop # => -4160
   puts EXCEL_CONST::CONSTANTS['_xlDialogChartSourceData'] # => 541

モジュール名を省略した例

   WIN32OLE.const_load(excel)
   puts WIN32OLE::XlTop # => -4160

タイプライブラリ名を指定した例

   module MSO
   end
 
   WIN32OLE.const_load('Microsoft Office 9.0 Object Library', MSO) 
   puts MSO::MsoLineSingle # => 1

--- new(server, host=nil) -> WIN32OLE
OLEオートメーションサーバを生成します。

引数で指定したCLSIDまたはPROGIDを持つOLEオートメーションサーバを生成します。生成に成功した場合、該当サーバを操作可能なWIN32OLEオブジェクトが返ります。

CLSIDおよびPROGIDについては[[m:WIN32OLE.connect]]を参照してください。

@param server OLEオートメーションサーバを示すPROGIDまたはCLSIDを文字列で指定します。
@param host サーバを生成するホストのホスト名またはIPアドレスを文字列で指定します。
            省略時は現在スクリプトを実行中のホストで生成します。

    WIN32OLE.new('Excel.Application') # => Excel OLE Automation WIN32OLE object.

    WIN32OLE.new('{00024500-0000-0000-C000-000000000046}') # => Excel OLE Automation WIN32OLE object.

--- ole_free(aWIN32OLE) -> Integer

引数で指定したオブジェクトを解放します。

このメソッドは主にWIN32OLEのデバッグおよびWIN32OLEを利用するミドルウェアの実装のために用意されています。このため、メソッドの内部動作は不定です。
COMの仕様とWIN32OLEの内部処理に熟知していない場合は使用しないでください。

@param aWIN32OLE 解放するWIN32OLEオブジェクト。
@return Releaseの戻り値。COMの仕様上は現在のオブジェクトの参照カウント値を示します。

--- ole_reference_count(aWIN32OLE) -> Integer

引数で指定したオブジェクトの現在の参照カウント値を返します。

このメソッドは主にWIN32OLEのデバッグおよびWIN32OLEを利用するミドルウェアの実装のために用意されています。このため、メソッドの内部動作は不定です。
COMの仕様とWIN32OLEの内部処理に熟知していない場合は使用しないでください。

@param aWIN32OLE 参照カウント値を求めるWIN32OLEオブジェクト。
@return AddRef呼び出し後のReleaseの戻り値。COMの仕様上は現在のオブジェクトの参照カウント値を示します。

--- ole_show_help(obj, helpcontext = nil) -> ()
WIN32OLEオブジェクトのヘルプファイルを表示します。

Windows標準のヘルプ表示コンポーネントのHHCtrl.OCXを利用して、オブジェクトに関連付けられたヘルプファイル（chmファイル）を表示します。

また、chmファイルのフルパス名を指定して表示させることも可能です。

@param obj [[c:WIN32OLE_TYPE]]オブジェクトまたは[[c:WIN32OLE_METHOD]]オブジェクト。
           直接ヘルプファイルのフルパス名を指定することも可能です。
@param helpcontext obj引数に[[c:WIN32OLE_TYPE]]オブジェクトまたは[[c:WIN32OLE_METHOD]]オブジェクトを指定した場合は、これらのオブジェクトの設定値を利用するため指定不要です。
                   obj引数にヘルプファイルのフルパス名を設定した場合は0を指定してください。

   excel = WIN32OLE.new('Excel.Application')
   typeobj = excel.ole_obj_help
   WIN32OLE.ole_show_help(typeobj) if typeobj.helpfile

オブジェクトが関連するヘルプファイルを持たない場合はRuntimeError（no helpfile of `オブジェクト名')を通知します。また、ヘルプファイルがインストールされていない場合は、RuntimeError（failed to open help file `ファイル名'）が通知されます。

== Instance Methods

#@if (version < "1.9.0")

--- [](name) -> object
--- [](name, param...) -> object
オブジェクトのプロパティを参照します。

注意： このメソッドはRuby-1.9以降で動作が変わります。Ruby-1.9ではプロパティ名をメソッド名としたメソッド呼び出し形式で記述してください。

[]の中にWIN32OLEオブジェクトのプロパティ名を指定することで、オブジェクトをHashのように扱ってプロパティ値を参照します。

パラメータ付きプロパティの場合は、プロパティ名に続けて引数を「,」で区切って列記します。

@param name プロパティ名を文字列で指定します。
@param param プロパティが引数を取る場合に指定します。

@return プロパティ値を返します。

   excel = WIN32OLE.new('Excel.Application')
   visible = excel['visible'] #=> false

上記のコードは以下と同等です。

   excel = WIN32OLE.new('Excel.Application')
   visible = excel.visible  #=> false

--- []=(name, value) -> ()
--- []=(name, param..., value) -> ()
オブジェクトのプロパティを設定します。

注意： このメソッドはRuby-1.9以降で動作が変わります。Ruby-1.9では[[c:WIN32OLE#setproperty]]を利用してください。

[]でプロパティ名を指定したプロパティに値を設定します。

パラメータ付きプロパティの場合は、プロパティ名に続けて引数を「,」で区切って列記します。

@param name プロパティ名を文字列で指定します。
@param param プロパティが引数を取る場合に指定します。
@param value プロパティに設定する値を指定します。

OLEオートメーションのプロパティはRubyの属性と異なり、パラメータを取ることができます。

たとえばExcelのWorksheetオブジェクトのCellsプロパティは桁位置と行番号の2つのパラメータを取ります。

これはVBでは次のように記述できます。

  sheet.Cells(1, 1) = sheet.Cells(1, 2) ' セルB1の内容をセルA1へ

Rubyでは上記のコードの右辺をVBと同じく「sheet.Cells(1, 2)」のように記述できますが、左辺の記述はできません。

そのため、次の例のように[]=メソッドを利用して、パラメータ付きプロパティを設定します。

   excel = WIN32OLE.new('Excel.Application')
   excel.visible = true
   sheet = excel.Workbooks.Add.Worksheets(1)
   sheet['Cells', 1, 2] = 321
   sheet['Cells', 1, 1] = sheet['Cells', 1, 2] #== sheet['Cells', 1, 1] = sheet.Cells(1, 2)

#@else

--- [](key...) -> object
オブジェクトのデフォルトプロパティを参照します。

OLEオートメーションにはデフォルトプロパティというプロパティ名を指定せずにアクセスできるプロパティがあります。

WIN32OLEからデフォルトプロパティにアクセスするには、[]内に必要なキーを「,」で区切って記述します。シンボルは文字列として扱います。

なおデフォルトプロパティは記述が省略できるプロパティ名に意味がないため、OLEオートメーション規約ではItemと命名することが決められています。

@param key プロパティでアクセスする情報を特定するキーを指定します。プロパティの特定に複数のキーが必要な場合は「,」で区切って列記します。

@return プロパティ値を返します。

  fsys = WIN32OLE.new('Scripting.FileSystemObject')
  fsys.Drives[:c].FreeSpace #=> Cドライブの空き容量

--- []=(key..., value) -> ()
オブジェクトのデフォルトプロパティを設定します。

OLEオートメーションにはデフォルトプロパティというプロパティ名を指定せずにアクセスできるプロパティがあります。

WIN32OLEからデフォルトプロパティにアクセスするには、[]内に必要なキーを記述します。

なおデフォルトプロパティは記述が省略できるプロパティ名には意味がありません。このためOLEオートメーション規約では一律にItemと命名することが決められています。

@param key プロパティでアクセスする情報を特定するキーを指定します。プロパティの特定に複数のキーが必要な場合は「,」で区切って列記します。
@param value プロパティに設定する値を指定します。

  dict = WIN32OLE.new('Scripting.Dictionary')
  dict[:a] = 0x41
  dict[:b] = 0x42
  dict[:a] #=> 65
  dict[:b] #=> 66

#@end


--- _getproperty(dispid, args, types) -> object
DISPIDとパラメータの型を指定してオブジェクトのプロパティを参照します。

アクセスするプロパティのインターフェイスを事前に知っている場合に、DISPIDとパラメータの型を指定してプロパティを参照します。

@param dispid プロパティのDISPID（メソッドを一意に特定する数値）を指定します。
@param args プロパティが引数を取る場合に配列で指定します。引数の順序は最左端の引数のインデックスを0とします。引数が不要な場合は空配列を指定します。
@param types プロパティが引数を取る場合に配列で引数の型を指定します。引数の順序は最左端の引数のインデックスを0とします。型の指定には、[[c:WIN32OLE::VARIANT]]の定数を利用します。引数が不要な場合は空配列を指定します。

このメソッドはCOMアーリーバインディングを利用することで外部プロセスサーバとのラウンドトリップを行い、処理速度の向上を目的としたものです。このため、DLLの形式で型情報（TYPELIB）を提供しているサーバに対してはあまり意味を持ちません。

@return プロパティ値を返します。

   DISPID_CELLS = 238
   include WIN32OLE::VARIANT
   excel = WIN32OLE.new('Excel.Application')
   puts excel._getproperty(558, [], []) # VisibleプロパティのDISPIDは558
   workbook = excel.Workbooks.Add
#@if (version < "1.9.0")
   sheet = workbook.Worksheets(1)
#@else
   sheet = workbook.Worksheets[1]
#@end
   sheet._setproperty(DISPID_CELLS, [1, 2, 'hello'], [VT_I2, VT_I2, VT_BSTR])
   puts sheet._getproperty(DISPID_CELLS, [1, 2], [VT_I2, VT_I2]).value  #=> 'hello'
   workbook.Close(:SaveChanges => false)
   excel.Quit

DISPIDは[[m:WIN32OLE_METHOD#dispid]]から取得できます。

--- _invoke(dispid, args, types) -> object | nil
DISPIDとパラメータの型を指定してオブジェクトのメソッドを呼び出します。

呼び出すメソッドのインターフェイスを事前に知っている場合に、DISPIDとパラメータの型を指定してメソッドを呼び出します。

このメソッドは引数の変換方法をプログラマが制御できるようにすることと、COMアーリーバインディングを利用して外部プロセスサーバとのラウンドトリップを減らして処理速度を向上させることを目的としたものです。後者の目的については、DLLの形式で型情報（TYPELIB）を提供しているサーバに対してはあまり意味を持ちません。そのため、型の高精度な制御が不要な場合は、直接メソッド名を指定したメソッド呼び出しを行うことを、プログラムの可読性の点から推奨します。

@param dispid メソッドのDISPID（メソッドを一意に特定する数値）を指定します。
@param args メソッドの引数を配列で指定します。引数の順序は最左端の引数のインデックスを0とします。引数が不要な場合は空配列を指定します。
@param types メソッドの引数の型を配列で指定します。引数の順序は最左端の引数のインデックスを0とします。型の指定には、[[c:WIN32OLE::VARIANT]]の定数を利用します。引数が不要な場合は空配列を指定します。
@return メソッドの返り値。ただし返り値を持たないメソッドの場合はnil。

   excel = WIN32OLE.new('Excel.Application')
   excel._invoke(302, [], []) #  DISPID 302は、Quitメソッド

MFCの制約により、バイト配列の型情報は通常[[c:WIN32OLE::VARIANT::VT_VARIANT]]となっている。このような場合に、バイト配列を与えるつもりで

 include WIN32OLE::VARIANT
 obj.method(DISPID, [[0, 1, 2, 3]], [VT_VARIANT])

のように記述すると、単に32ビット整数（VT_I4）の配列が送られることになり空間効率が低下します。

引数の最終的な型がわかっている場合は、下記の例のように型指定パラメータには実際の型を指定してください。

 include WIN32OLE::VARIANT
 obj.method(DISPID, [[0, 1, 2, 3]], [VT_BYREF | VT_ARRAY | VT_UI1])

なお、VB6で作成したCOMコンポーネントのパラメータに配列を与える場合は、[[c:WIN32OLE::VARIANT::VT_BYREF]]の指定が必須です。

DISPIDは[[m:WIN32OLE_METHOD#dispid]]から取得できます。

--- _setproperty(dispid, args, types) -> ()
DISPIDとパラメータの型を指定してオブジェクトのプロパティを設定します。

アクセスするプロパティのインターフェイスを事前に知っている場合に、DISPIDとパラメータの型を指定してプロパティを設定します。

このメソッドはCOMアーリーバインディングを利用することで外部プロセスサーバとのラウンドトリップを行い、処理速度の向上を目的としたものです。このため、DLLの形式で型情報（TYPELIB）を提供しているサーバに対してはあまり意味を持ちません。

@param dispid プロパティのDISPID（メソッドを一意に特定する数値）を指定します。
@param args 引数を配列で指定します。引数の順序は最左端の引数のインデックスを0とします。プロパティに対する設定値は最右端の要素です。
@param types プロパティの引数の型を配列で指定します。引数の順序は最左端の引数のインデックスを0とします。型の指定には、[[c:WIN32OLE::VARIANT]]の定数を利用します。

   DISPID_CELLS = 238
   include WIN32OLE::VARIANT
   excel = WIN32OLE.new('Excel.Application')
   puts excel._setproperty(558,      # VisibleプロパティのDISPIDは558
                          [true], [VT_BOOL])
   workbook = excel.Workbooks.Add
#@if (version < "1.9.0")
   sheet = workbook.Worksheets(1)
#@else
   sheet = workbook.Worksheets[1]
#@end
   sheet._setproperty(DISPID_CELLS, [1, 2, 'hello'], [VT_I2, VT_I2, VT_BSTR])
   puts sheet._getproperty(DISPID_CELLS, [1, 2], [VT_I2, VT_I2]).value  #=> 'hello'
   workbook.Close(:SaveChanges => false)
   excel.Quit

DISPIDは[[m:WIN32OLE_METHOD#dispid]]から取得できます。

--- each {|i|...}
#@todo

Iterates over each item of OLE collection which has IEnumVARIANT
interface.

   excel = WIN32OLE.new('Excel.Application')
   book = excel.workbooks.add
   sheets = book.worksheets(1)
   cells = sheets.cells("A1:A5")
   cells.each do |cell|
     cell.value = 10
   end

--- invoke(method, *args)  -> return value of method.
#@todo

Runs OLE method. The first argument specifies the method name
of OLE Automation object. The others specify argument of the
method. If you can not execute method directly, then use this
method instead.

  excel = WIN32OLE.new('Excel.Application')
  excel.invoke('Quit')  # => same as excel.Quit

--- method_missing(id, *args)
#@todo

Calls WIN32OLE#invoke method.

--- ole_activex_initialize -> Qnil
#@todo

Initialize WIN32OLE object(ActiveX Control) by calling IPersistMemory::InitNew.

Before calling OLE method, some kind of the ActiveX controls
created with MFC should be initialized by calling IPersistXXX::InitNew.

If and only if you recieved the exception "HRESULT error code:
0x8000ffff catastrophic failure", try this method before invoking
any ole_method.

   obj = WIN32OLE.new("ProgID_or_GUID_of_ActiveX_Control")
   obj.ole_activex_initialize
   obj.method(...)

--- ole_free -> ()

selfが参照するCOMオブジェクトを解放します。

selfが参照するCOMオブジェクトのIUnknown::Releaseを呼び出すことで、COMオブジェクトを開放します。
ole_freeを呼び出した後は、このオブジェクトに対する操作は行えません。

  excel = WIN32OLE.new('Excel.Application')
  excel.ole_free  # オブジェクトの解放
  excel.Quit      #=> RuntimeError (failed to get Dispatch Interface)

通常は利用されなくなったWIN32OLEオブジェクトはGCのタイミングで自動的に解放されるため、当メソッドを呼び出す必要はありません。Officeのような外部プロセスサーバ呼び出し時に、スクリプト終了後もサーバが解放されない場合に強制的にサーバを終了するために当メソッドを利用できます。
ただし、現実には途中で生成される子オブジェクトからの逆参照などがあるため、WIN32OLEがIUnknown::Releaseを呼び出してもオブジェクトが解放されるとは限りません。

  excel = WIN32OLE.new('Excel.Application')
  workbook = excel.Workbooks.Open('workbook.xls') 
  workbook.Close(:SaveChanges => false)
  workbook.ole_free
  excel.ole_free
  # この時点でExcel.EXEは終了しない

上の例では、excel.Workbooks.Openの行で、excel.Workbooksオブジェクトが生成されています。しかし、後続の処理で該当オブジェクトが解放されていないため、Workbooksオブジェクトによって参照されているexcelオブジェクトは解放されません。
それに対して下の例では正しく解放されます。

  excel = WIN32OLE.new('Excel.Application')
  books = excel.Workbooks
  workbook = books.Open('workbook.xls')
  books.ole_free
  workbook.Close(:SaveChanges => false)
  workbook.ole_free
  excel.ole_free

--- ole_func_methods
#@todo

Returns the array of WIN32OLE_METHOD object . The element of
the array is functional method of WIN32OLE object.

   excel = WIN32OLE.new('Excel.Application')
   properties = excel.ole_func_methods

--- ole_get_methods
#@todo

Returns the array of WIN32OLE_METHOD object . The element of
the array is property (gettable) of WIN32OLE object.

   excel = WIN32OLE.new('Excel.Application')
   properties = excel.ole_get_methods

--- ole_method(method)
--- ole_method_help(method)
#@todo


Returns WIN32OLE_METHOD object corresponding with method specified
by 1st argument.

   excel = WIN32OLE.new('Excel.Application')
   method = excel.ole_method_help('Quit')

--- ole_methods
#@todo

Returns the array of WIN32OLE_METHOD object. The element is OLE
method of WIN32OLE object.

   excel = WIN32OLE.new('Excel.Application')
   methods = excel.ole_methods

--- ole_obj_help -> WIN32OLE_TYPE | nil
--- ole_type -> WIN32OLE_TYPE | nil
[[c:WIN32OLE_TYPE]]オブジェクトを返します。

[[c:WIN32OLE_TYPE]]オブジェクトは、WIN32OLEオブジェクトの文書情報と型情報を保持するオブジェクトです。

@return オブジェクトに関連する[[c:WIN32OLE_TYPE]]オブジェクトを返します。
        オブジェクトがドキュメント情報を持たない場合はnilを返します。

   excel = WIN32OLE.new('Excel.Application')
   tobj = excel.ole_obj_help

--- ole_put_methods
#@todo

Returns the array of WIN32OLE_METHOD object . The element of
the array is property (settable) of WIN32OLE object.

   excel = WIN32OLE.new('Excel.Application')
   properties = excel.ole_put_methods


--- setproperty(name, val) -> ()
--- setproperty(name, args..., val) -> ()

オブジェクトのプロパティを設定します。

#@if (version < "1.9.0")
@param name プロパティ名を文字列で指定します。
#@else
@param name プロパティ名を文字列またはシンボルで指定します。
#@end
@param val プロパティに設定する値を指定します。
@param args 集合的なプロパティに対する設定項目を特定するための引数を指定します。

OLEオートメーションのプロパティはRubyの属性と異なり、パラメータを取ることができます。

たとえばExcelのWorksheetオブジェクトのCellsプロパティは桁位置と行番号の2つのパラメータを取ります。

これはVBでは次のように記述できます。

  sheet.Cells(1, 1) = sheet.Cells(1, 2) ' セルB1の内容をセルA1へ

Rubyでは上記のコードの右辺をVBと同じく「sheet.Cells(1, 2)」のように記述できますが、左辺の記述はできません。

そのため、次の例のようにsetpropertyメソッドを利用して、パラメータ付きプロパティを設定します。

#@if (version < "1.9.0")

   excel = WIN32OLE.new('Excel.Application')
   excel.visible = true
   sheet = excel.Workbooks.Add.Worksheets(1)
   sheet.setproperty('Cells', 1, 2, 32)
   sheet.setproperty('Cells', 1, 1, sheet.Cells(1, 2))

#@else

   excel = WIN32OLE.new('Excel.Application')
   excel.visible = true
   sheet = excel.Workbooks.Add.Worksheets[1]
   sheet.setproperty(:Cells, 1, 2, 32)
   sheet.setproperty(:Cells, 1, 1, sheet.Cells(1, 2))

#@end

#@since 1.9.1

--- ole_query_interface(iid) -> WIN32OLE

IID（インターフェイスID）を指定してオブジェクトの別のインターフェイスを持つオブジェクトを取得します。

オブジェクトが複数のオートメーション用インターフェイスを持つ場合に、当メソッドを利用して既定のインターフェイスとは異なるインターフェイスを取得します。

@param iid 取得するインターフェイスのIIDを文字列で指定します。
@return iidパラメータで指定したインターフェイスを持つWIN32OLEオブジェクト
@raise WIN32OLERuntimeError 指定したIIDをオブジェクトが持たない場合に通知されます。

    ie = WIN32OLE.new('InternetExplorer.Application')
    ie_web_app = ie.ole_query_interface('{0002DF05-0000-0000-C000-000000000046}')

上例のie_web_appは、ieと同じインスタンスとなります。

COMの仕様ではIUnknown::QueryInterfaceは交換法則を満たすと同時に、同じIID問い合わせに対しては常に同一のインターフェイスを返すことが決められています。

このため、正しく実装されたOLEオートメーションサーバでは本メソッドが意味を持つことはありません。というのは、2つ以上の異なるWIN32OLEで操作可能なインターフェイスを持つということは、IID_IDispatch（OLEオートメーションのインターフェイスID）を指定した問い合わせに対して異なるインターフェイスを返すということになるからです。これは、結果的に呼び出し側プログラムがいつでも間違えたインターフェイスを呼び出す可能性を持つということを意味します。当然、それはサーバ実装のバグです。

問題は、C++のvtblアクセスや.NET FrameworkのCOM Interopのために静的型情報が必要となることです。このため、一度あるインターフェイスを返すことに決めた場合、実際に返すインターフェイスが元のインターフェイスを継承していたとしても、ドキュメント上は異なるインターフェイスとして定義しなければ追加のメソッドが呼び出せません。

たとえば、当メソッドの存在理由である[[url:http://www.ruby-forum.com/topic/109954]]（なお、元のパッチと異なりGUIDの統一フォーマットを利用するように改造されているため、IIDの前後に{}が必要です）には、Solutionオブジェクトに対してSolution2オブジェクトの取得を依頼するために、必要ということになっています。実際、Solutionプロパティが返すのは、この場合はSolutionインターフェイスを継承したSolution2インターフェイスです。しかし、Solutionプロパティの型情報はSolutionインターフェイスを返すことになっているため、静的に型を解決している場合は、追加のメソッドの呼び出しを記述できません。

しかし、WIN32OLEが利用するIDispatch呼び出しは、IDispatchによるインタープリタなので、メソッド名による動的なメソッド検索が行われます。このため、Solutionオブジェクトに対してSolution2で追加されたメソッド（たとえばGetProjectTemplate）を正しく呼び出せます。つまり、[[url:http://www.ruby-forum.com/topic/109954]]で例示されているようなole_query_interfaceメソッドの呼び出しは不要です。

もし、当メソッドの呼び出しが本当に必要なのであれば、まず、該当するOLEオートメーションサーバの修正を依頼してください。その実装は正しくありません。

正しく実装されたオブジェクトに対して当メソッドを適用すると、結果として、同一オブジェクトの参照カウント値を無駄に増加させることになります。

--- ole_typelib -> The WIN32OLE_TYPELIB object 
#@todo

Returns the WIN32OLE_TYPELIB object. The object represents the
type library which contains the WIN32OLE object.

   excel = WIN32OLE.new('Excel.Application')
   tlib = excel.ole_typelib
   puts tlib.name  # -> 'Microsoft Excel 9.0 Object Library'

#@end

== Constants
--- VERSION  -> String

Major.Minor.Patch形式のWIN32OLEのバージョン番号を示す文字列です。

--- ARGV -> [object]

直前のメソッド呼び出しの引数を格納した配列です。

OLEオートメーションでは呼び出し先が引数に対して値を設定できます。しかし、Rubyのメソッド引数は値のみを取るため、そのままでは呼び出し先が設定した値を参照できません。このような場合、ARGVを参照することで呼び出し先の設定値を参照できます。

以下のリストは、VBで開発したオブジェクトのメソッド呼び出しを例としています。このメソッド（Accm）は、第1引数で指定した演算を第2引数と第3引数に適用し、結果を第2引数に設定します。

  ' VB (OLE Automation server)
  Public Sub Accm(ByVal Operator, ByRef Accumulator, ByVal Operand)
      If Operator = "*" Then
          Accmulator = Accmulator * Operand
      Else If Operator = "+" Then
          Accmulator = Accmulator + Operand
      End If
  End Sub
 
  # Ruby
  x = 10
  obj.Accm '*', x, 11
  p x               # -> 10 …… 呼び出しによって影響を受けない
  p WIN32OLE::ARGV  # -> ['*', 110, 11] …… 結果はARGVの対応する引数に反映される
  obj.Accm '+', 10, 11
  p WIN32OLE::ARGV  # -> ['+', 21, 11]

直前のメソッド呼び出しが例外となった場合、ARGVの設定内容は呼び出し前の状態が保たれます。つまり、WIN32OLE自身がARGVの内容を消去するのは、メソッド呼び出しに成功した場合のみです。このため最後のメソッド呼び出しが引数にオブジェクトを返すタイプのメソッドだった場合、GCにオブジェクトを回収させるために、呼び出し側でARGVを消去してください。

  ' VB (OLE Automation server)
  Public Sub GetInterface(ByRef obj)
      Set Obj = New OleObject
  End Sub

  # Ruby
  obj.GetInterface nil   # 引数の数を合わせるためダミー引数を指定
  WIN32OLE::ARGV.clear   # 通常は、後続のメソッド呼び出しによって消去される

--- CP_ACP -> Fixnum

Windows既定のANSIコードページ（0）を示します。

--- CP_MACCP -> Fixnum

Macintoshコードページ（2）を示します。

--- CP_OEMCP -> Fixnum

OEMコードページ（1）を示します。

--- CP_SYMBOL -> Fixnum

文字コードの変換にシンボルを利用することを示します（42）。

--- CP_THREAD_ACP -> Fixnum

現在実行中のスレッドの既定のコードページ（3）を示します。

Windowsのコードページはスレッド毎に異なる値を設定できます。

--- CP_UTF7 -> Fixnum

文字コードの変換にUTF-7を利用することを示します（65000）。

--- CP_UTF8 -> Fixnum

文字コードの変換にUTF-8を利用することを示します（65001）。

--- LOCALE_SYSTEM_DEFAULT  -> Fixnum

システム既定のロケールを示すLCID(0x0800)です。WIN32OLEがオートメーションを利用する場合の既定値です。

--- LOCALE_USER_DEFAULT  -> Fixnum

ユーザ既定のロケールを示すLCID(0x0400)です。
